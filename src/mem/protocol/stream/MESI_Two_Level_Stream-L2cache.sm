/**
 * Copyright (c) 1999-2013 Mark D. Hill and David A. Wood
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L2Cache, "MESI Directory L2 Cache CMP", interface="AbstractStreamAwareController")
 : CacheMemory * L2cache;
   Cycles l2_request_latency := 2;
   Cycles l2_response_latency := 2;
   Cycles to_l1_latency := 1;

   bool multicast_test := "false";

  // Message Queues
  // From local bank of L2 cache TO the network
  MessageBuffer * DirRequestFromL2Cache, network="To", virtual_network="0",
    vnet_type="request";  // this L2 bank -> Memory

  MessageBuffer * L1RequestFromL2Cache, network="To", virtual_network="2",
    vnet_type="request";  // this L2 bank -> a local L1

  MessageBuffer * responseFromL2Cache, network="To", virtual_network="1",
    vnet_type="response";  // this L2 bank -> a local L1 || Memory

  // FROM the network to this local bank of L2 cache
  MessageBuffer * unblockToL2Cache, network="From", virtual_network="2",
    vnet_type="unblock";  // a local L1 || Memory -> this L2 bank

  MessageBuffer * L1RequestToL2Cache, network="From", virtual_network="0",
    vnet_type="request";  // a local L1 -> this L2 bank

  MessageBuffer * responseToL2Cache, network="From", virtual_network="1",
    vnet_type="response";  // a local L1 || Memory -> this L2 bank

  /**
   * ! Sean: StreamAwareCache
   * ! Ruby requires one virtual network per To/From buffer.
   * ! I use virtual_network 4 for stream migration request, but they
   * ! are actually the lowest priority.
   */

  MessageBuffer * streamIndirectFromL2Cache, network="To", virtual_network="3",
    vnet_type="StreamIndirectRequest"; // this L2 bank -> other L2 bank
  MessageBuffer * streamIndirectToL2Cache, network="From", virtual_network="3",
    vnet_type="StreamIndirectRequest"; // other L2 bank -> this L2 bank
  
  MessageBuffer * streamMigrateFromL2Cache, network="To", virtual_network="4",
    vnet_type="StreamMigrateRequest"; // this L2 bank -> other L2 bank
  MessageBuffer * streamMigrateToL2Cache, network="From", virtual_network="4",
    vnet_type="StreamMigrateRequest"; // other L2 bank -> this L2 bank

{
  // STATES
  state_declaration(State, desc="L2 Cache states", default="L2Cache_State_NP") {
    // Base states
    NP, AccessPermission:Invalid, desc="Not present in either cache";
    SS, AccessPermission:Read_Only, desc="L2 cache entry Shared, also present in one or more L1s";
    M, AccessPermission:Read_Write, desc="L2 cache entry Modified, not present in any L1s", format="!b";
    MT, AccessPermission:Maybe_Stale, desc="L2 cache entry Modified in a local L1, assume L2 copy stale", format="!b";

    // L2 replacement
    M_I, AccessPermission:Busy, desc="L2 cache replacing, have all acks, sent dirty data to memory, waiting for ACK from memory";
    MT_I, AccessPermission:Busy, desc="L2 cache replacing, getting data from exclusive";
    MCT_I, AccessPermission:Busy, desc="L2 cache replacing, clean in L2, getting data or ack from exclusive";
    I_I, AccessPermission:Busy, desc="L2 replacing clean data, need to inv sharers and then drop data";
    S_I, AccessPermission:Busy, desc="L2 replacing dirty data, collecting acks from L1s";

    // Transient States for fetching data from memory
    IVV, AccessPermission:Busy, desc="L2 idle, got single L1_GETV, issued memory fetch, have not seen response yet";
    ISS, AccessPermission:Busy, desc="L2 idle, got single L1_GETS, issued memory fetch, have not seen response yet";
    IS, AccessPermission:Busy, desc="L2 idle, got L1_GET_INSTR or multiple L1_GETS, issued memory fetch, have not seen response yet";
    IM, AccessPermission:Busy, desc="L2 idle, got L1_GETX, issued memory fetch, have not seen response(s) yet";

    // Stream Store. In LLC update.
    SS_M, AccessPermission:Busy, desc="L2 updating from SS, collecting acks from L1s";
    MT_M, AccessPermission:Busy, desc="L2 updating from MT, waiting for data";
    NP_M, AccessPermission:Busy, desc="L2 updating from NP, issued memory fetch, have not seen response yet";

    // Blocking states
    SS_MB, AccessPermission:Busy, desc="Blocked for L1_GETX from SS";
    MT_MB, AccessPermission:Busy, desc="Blocked for L1_GETX from MT";

    MT_IIB, AccessPermission:Busy, desc="Blocked for L1_GETS from MT, waiting for unblock and data";
    MT_IB, AccessPermission:Busy, desc="Blocked for L1_GETS/L1_GETV from MT, got unblock, waiting for data";
    MT_SB, AccessPermission:Busy, desc="Blocked for L1_GETS from MT, got data, waiting for unblock";
    MT_VVB, AccessPermission:Busy, desc="Blocked for L1_GETV from MT, waiting for unblock and data";
    MT_VB, AccessPermission:Busy, desc="Blocked for L1_GETV from MT, got data, waiting for unblock";
  }

  // EVENTS
  enumeration(Event, desc="L2 Cache events") {
    // L2 events

    // events initiated by the local L1s
    L1_GET_INSTR,            desc="a L1I GET INSTR request for a block maped to us";
    L1_GETS,                 desc="a L1D GETS request for a block maped to us";
    L1_GETV,                 desc="a volatile load that will not be cached at upper";
    L1_GETH,                 desc="a load brings the data to L2 and no response";
    L1_GETX,                 desc="a L1D GETX request for a block maped to us";
    L1_UPGRADE,              desc="a L1D GETX request for a block maped to us";

    L1_PUTX,                 desc="L1 replacing data";
    L1_PUTX_old,             desc="L1 replacing data, but no longer sharer";

    // events initiated by this L2
    L2_Replacement,     desc="L2 Replacement", format="!r";
    L2_Replacement_clean,     desc="L2 Replacement, but data is clean", format="!r";

    // events from memory controller
    Mem_Data,     desc="data from memory", format="!r";
    Mem_Ack,     desc="ack from memory", format="!r";

    // M->S data writeback
    WB_Data,  desc="data from L1";
    WB_Data_clean,  desc="clean data from L1";
    Ack,      desc="writeback ack";
    Ack_all,      desc="writeback ack";

    Unblock, desc="Unblock from L1 requestor";
    Pre_Unblock, desc="(Not Final) Unblock from L1 requestors, used when we are expecting multiple unblocks.";
    Exclusive_Unblock, desc="Unblock from L1 requestor";

    MEM_Inv,  desc="Invalidation from directory";
    MEM_InvR, desc="Invalidation from directory, but as a request.";

    STREAM_CONFIG,  desc="StreamConfig req";
    STREAM_FLOW,    desc="Flow control message for stream";
    STREAM_REQ,     desc="Received a stream indirect request from other LLC";
    STREAM_END,     desc="StreamEnd req";
    STREAM_STORE,   desc="StreamStore req";
    STREAM_FORWARD, desc="StreamForward req";
    STREAM_COMMIT,  desc="StreamCommit req";
    STREAM_NDC,     desc="StreamNDC req";
  }

  // TYPES

  // CacheEntry
  structure(Entry, desc="...", interface="AbstractCacheEntry") {
    State CacheState,                 desc="cache state";
    NetDest Sharers,                  desc="tracks the L1 shares on-chip";
    MachineID Exclusive,              desc="Exclusive holder of block";
    DataBlock DataBlk,                desc="data for the block";
    bool Dirty, default="false",      desc="data is dirty";
    DynamicStreamSliceIdVec sliceIds, desc="tempoary slices for this entry";
    int pendingUnblocks,              desc="Number of pending unblocks from multicast requestors";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr addr,                        desc="Physical address for this TBE";
    State TBEState,                   desc="Transient state";
    DataBlock DataBlk,                desc="Buffer for the data block";
    bool Dirty, default="false",      desc="Data is Dirty";
    bool cachedUpper, default="true", desc="Whether this block is cache by upper level";

    NetDest L1_GetS_IDs,              desc="Set of the internal processors that want the block in shared state";
    NetDest L1_GetV_IDs,              desc="Set of the internal processors that want the block via L1_GETV";
    MachineID L1_GetX_ID,             desc="ID of the L1 cache to forward the block to once we get a response";
    int pendingAcks,                  desc="number of pending acks for invalidates during writeback";
    DynamicStreamSliceIdVec sliceIds, desc="Stream slices meta-data";
    DataBlock streamStoreBlk,         desc="Buffer for the update data";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    int size();
  }

  TBETable TBEs, template="<L2Cache_TBE>", constructor="m_number_of_TBEs";

  /**
   * ! Sean: StreamAwareCache
   */
  structure(LLCStreamEngine, external="yes", desc="Stream Engine at LLC") {
    void receiveStreamConfigure(PacketPtr);
    void receiveStreamEnd(PacketPtr);
    void receiveStreamMigrate(LLCDynamicStreamPtr, bool);
    void receiveStreamFlow(DynamicStreamSliceId);
    void receiveStreamDataVec(Cycles, Addr, DynamicStreamSliceIdVec, DataBlock, DataBlock);
    void receiveStreamIndirectRequest(RequestMsg);
    void receiveStreamForwardRequest(RequestMsg);
    void receiveStreamCommit(DynamicStreamSliceId);
    void receiveStreamNDCRequest(PacketPtr);
    void notifyStreamRequestMiss(DynamicStreamSliceIdVec);
  }

  LLCStreamEngine se, constructor="this, m_streamMigrateFromL2Cache_ptr, m_L1RequestToL2Cache_ptr, m_streamIndirectFromL2Cache_ptr, m_responseFromL2Cache_ptr";

  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  Cycles ticksToCycles(Tick t);

  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);
  void setHitCacheLevel(RequestStatisticPtr, int);
  RequestStatisticPtr getRequestStatistic(PacketPtr);
  void recordLLCReqQueueStats(RequestStatisticPtr, DynamicStreamSliceIdVec, bool);
  void incrementLLCIndReqQueueStats();

  bool isStreamSublineEnabled();
  MessageSizeType getMessageSizeType(int);

  // inclusive cache, returns L2 entries only
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    return static_cast(Entry, "pointer", L2cache[addr]);
  }

  bool isSharer(Addr addr, MachineID requestor, Entry cache_entry) {
    if (is_valid(cache_entry)) {
      return cache_entry.Sharers.isElement(requestor);
    } else {
      return false;
    }
  }

  void addSharer(Addr addr, MachineID requestor, Entry cache_entry) {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "machineID: %s, requestor: %s, address: %#x\n",
            machineID, requestor, addr);
    cache_entry.Sharers.add(requestor);
  }

  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:NP;
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    // MUST CHANGE
    if (is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s %s\n", tbe.TBEState, L2Cache_State_to_permission(tbe.TBEState));
      return L2Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s %s\n", cache_entry.CacheState, L2Cache_State_to_permission(cache_entry.CacheState));
      return L2Cache_State_to_permission(cache_entry.CacheState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L2Cache_State_to_permission(state));
    }
  }

  Event L1Cache_request_type_to_event(CoherenceRequestType type, Addr addr,
                                      NetDest requestors, Entry cache_entry) {
    if (type == CoherenceRequestType:GETS) {
      return Event:L1_GETS;
    } else if (type == CoherenceRequestType:GETU) {
      return Event:L1_GETV;
    } else if (type == CoherenceRequestType:GETH) {
      return Event:L1_GETH;
    } else if (type == CoherenceRequestType:GET_INSTR) {
      return Event:L1_GET_INSTR;
    } else if (type == CoherenceRequestType:GETX) {
      return Event:L1_GETX;
    } else if (type == CoherenceRequestType:UPGRADE) {
      MachineID requestor := requestors.singleElement();
      if (is_valid(cache_entry) && cache_entry.Sharers.isElement(requestor) ) {
        return Event:L1_UPGRADE;
      } else {
        return Event:L1_GETX;
      }
    } else if (type == CoherenceRequestType:PUTX) {
      MachineID requestor := requestors.singleElement();
      if (isSharer(addr, requestor, cache_entry)) {
        return Event:L1_PUTX;
      } else {
        return Event:L1_PUTX_old;
      }
    // ! Sean: StreamAwareCache.
    } else if (type == CoherenceRequestType:STREAM_STORE) {
      return Event:STREAM_STORE;
    } else if (type == CoherenceRequestType:STREAM_FORWARD) {
      return Event:STREAM_FORWARD;
    } else if (type == CoherenceRequestType:STREAM_NDC) {
      return Event:STREAM_NDC;
    } else {
      DPRINTF(RubySlicc, "address: %#x, Request Type: %s\n", addr, type);
      error("Invalid L1 forwarded request type");
    }
  }

  int getPendingAcks(TBE tbe) {
    return tbe.pendingAcks;
  }

  bool isDirty(Entry cache_entry) {
    assert(is_valid(cache_entry));
    return cache_entry.Dirty;
  }

  // ** OUT_PORTS **

  out_port(L1RequestL2Network_out, RequestMsg, L1RequestFromL2Cache);
  out_port(DirRequestL2Network_out, RequestMsg, DirRequestFromL2Cache);
  out_port(responseL2Network_out, ResponseMsg, responseFromL2Cache);

  // ! Sean: StreamAwareCache
  // For the stream migrate and indirect request.
  out_port(streamMigrateFromL2Cache_out, StreamMigrateRequestMsg, streamMigrateFromL2Cache);
  out_port(streamIndirectFromL2Cache_out, RequestMsg, streamIndirectFromL2Cache);

  in_port(L1unblockNetwork_in, ResponseMsg, unblockToL2Cache, rank = 4) {
    if(L1unblockNetwork_in.isReady(clockEdge())) {
      peek(L1unblockNetwork_in,  ResponseMsg) {
        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        State state := getState(tbe, cache_entry, in_msg.addr);
        DPRINTF(RubySlicc, "Addr: %#x State: %s Sender: %s Type: %s Dest: %s\n",
                in_msg.addr, state,
                in_msg.Sender, in_msg.Type, in_msg.Destination);

        assert(in_msg.Destination.isElement(machineID));
        if (in_msg.Type == CoherenceResponseType:EXCLUSIVE_UNBLOCK) {
          trigger(Event:Exclusive_Unblock, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceResponseType:UNBLOCK) {
          /**
           * Special case for MT_VVB and MT_VB, as we may expect
           * multiple Unblocks.
           */
          if (state == State:MT_VVB || state == State:MT_VB) {
            assert(is_valid(cache_entry));
            int pendingUnblocks := cache_entry.pendingUnblocks;
            if (pendingUnblocks > 1) {
              trigger(Event:Pre_Unblock, in_msg.addr, cache_entry, tbe);
            } else if (pendingUnblocks == 1) {
              trigger(Event:Unblock, in_msg.addr, cache_entry, tbe);
            } else {
              error("Zero PendingUnblocks when receiving Unblock");
            }
          } else {
            trigger(Event:Unblock, in_msg.addr, cache_entry, tbe);
          }
        } else {
          error("unknown unblock message");
        }
      }
    }
  }

  // Response  L2 Network - response msg to this particular L2 bank
  in_port(responseL2Network_in, ResponseMsg, responseToL2Cache, rank = 3) {
    if (responseL2Network_in.isReady(clockEdge())) {
      peek(responseL2Network_in, ResponseMsg) {
        // test wether it's from a local L1 or an off chip source
        assert(in_msg.Destination.isElement(machineID));
        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        if(machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {
          if(in_msg.Type == CoherenceResponseType:DATA) {
            if (in_msg.Dirty) {
              trigger(Event:WB_Data, in_msg.addr, cache_entry, tbe);
            } else {
              trigger(Event:WB_Data_clean, in_msg.addr, cache_entry, tbe);
            }
          } else if (in_msg.Type == CoherenceResponseType:ACK) {
            if ((getPendingAcks(tbe) - in_msg.AckCount) == 0) {
              trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
            } else {
              trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
            }
          } else {
            error("unknown message type");
          }

        } else { // external message
          if(in_msg.Type == CoherenceResponseType:MEMORY_DATA) {
              trigger(Event:Mem_Data, in_msg.addr, cache_entry, tbe);
          } else if(in_msg.Type == CoherenceResponseType:MEMORY_ACK) {
              trigger(Event:Mem_Ack, in_msg.addr, cache_entry, tbe);
          } else if(in_msg.Type == CoherenceResponseType:INV) {
              DPRINTF(RubySlicc, "Addr: %#x MemInv TBEs %d.\n", in_msg.addr, TBEs.size());
              trigger(Event:MEM_Inv, in_msg.addr, cache_entry, tbe);
          } else if(in_msg.Type == CoherenceResponseType:PTW) {
            enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
              out_msg.addr := in_msg.addr;
              out_msg.Type := CoherenceResponseType:PTW;
              out_msg.Sender := machineID;
              out_msg.Destination := in_msg.Destination;
              out_msg.DataBlk := in_msg.DataBlk;
              out_msg.MessageSize := MessageSizeType:Response_Data;
            }
            Tick delay := responseL2Network_in.dequeue(clockEdge());
            profileMsgDelay(1, ticksToCycles(delay));
          } else {
            error("unknown message type");
          }
        }
      }
    }  // if not ready, do nothing
  }

  // L1 Request
  in_port(L1RequestL2Network_in, RequestMsg, L1RequestToL2Cache, rank = 2) {
    if(L1RequestL2Network_in.isReady(clockEdge())) {
      peek(L1RequestL2Network_in,  RequestMsg) {
        DPRINTF(RubySlicc, "Addr: %#x Req: %s Type: %s Slices: %s Dest: %s\n",
                in_msg.addr, 
                in_msg.Requestors, in_msg.Type, in_msg.sliceIds, in_msg.Destination);

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        assert(in_msg.Destination.isElement(machineID));

        if (in_msg.Requestors.count() == 1 &&
            machineIDToMachineType(in_msg.Requestors.singleElement()) == MachineType:Directory) {
          /**
           * Handle INV request from Directory.
           */
          assert(in_msg.Type == CoherenceRequestType:INV);
          DPRINTF(RubySlicc, "Addr: %#x MemInvAsRequest TBEs %d.\n", in_msg.addr, TBEs.size());
          trigger(Event:MEM_InvR, in_msg.addr, cache_entry, tbe);

        } else {

          /**
           * ! Sean: StreamAwareCache
           */
          if (in_msg.Type == CoherenceRequestType:STREAM_CONFIG) {
            trigger(Event:STREAM_CONFIG, in_msg.addr, cache_entry, tbe);
          } else if (in_msg.Type == CoherenceRequestType:STREAM_FLOW) {
            trigger(Event:STREAM_FLOW, in_msg.addr, cache_entry, tbe);
          } else if (in_msg.Type == CoherenceRequestType:STREAM_COMMIT) {
            trigger(Event:STREAM_COMMIT, in_msg.addr, cache_entry, tbe);
          } else if (in_msg.Type == CoherenceRequestType:STREAM_END) {
            trigger(Event:STREAM_END, in_msg.addr, cache_entry, tbe);
          } else if (in_msg.Type == CoherenceRequestType:PTW) {
            peek(L1RequestL2Network_in, RequestMsg) {
              enqueue(DirRequestL2Network_out, RequestMsg, l2_request_latency) {
                out_msg.addr := in_msg.addr;
                out_msg.Type := CoherenceRequestType:PTW;
                out_msg.Requestors.add(machineID);
                out_msg.Destination.add(mapAddressToMachine(in_msg.addr, MachineType:Directory));
                out_msg.MessageSize := MessageSizeType:Control;
              }
              Tick delay := L1RequestL2Network_in.dequeue(clockEdge());
              profileMsgDelay(0, ticksToCycles(delay));
            }
          } else {

            if (is_valid(cache_entry)) {
              // The L2 contains the block, so proceeded with handling the request
              // Hit.
              setHitCacheLevel(in_msg.requestStatistic, 2);
              trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                    in_msg.Requestors, cache_entry),
                      in_msg.addr, cache_entry, tbe);
            } else {
              if (in_msg.sliceIds.isValid()) {
                DPRINTF(RubyStream, "Miss stream request [%lu, +%lu).\n", 
                  in_msg.sliceIds.singleSliceId().getStartIdx(),
                  in_msg.sliceIds.singleSliceId().getNumElements());
              }
              if (L2cache.cacheAvail(in_msg.addr)) {
                // Miss.
                setHitCacheLevel(in_msg.requestStatistic, 4);
                // L2 does't have the line, but we have space for it in the L2
                trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                      in_msg.Requestors, cache_entry),
                        in_msg.addr, cache_entry, tbe);
              } else {
                // No room in the L2, so we need to make room before handling the request
                Entry L2cache_entry := getCacheEntry(L2cache.cacheProbe(in_msg.addr));
                if (isDirty(L2cache_entry)) {
                  trigger(Event:L2_Replacement, L2cache.cacheProbe(in_msg.addr),
                          L2cache_entry, TBEs[L2cache.cacheProbe(in_msg.addr)]);
                } else {
                  trigger(Event:L2_Replacement_clean, L2cache.cacheProbe(in_msg.addr),
                          L2cache_entry, TBEs[L2cache.cacheProbe(in_msg.addr)]);
                }
              }
            }

          }
        }
      }
    }
  }

  // ! Sean: StreamAwareCache
  // Stream indirect request.
  in_port(streamIndirectToL2Cache_in, RequestMsg, streamIndirectToL2Cache, rank = 1) {
    if(streamIndirectToL2Cache_in.isReady(clockEdge())) {
      peek(streamIndirectToL2Cache_in,  RequestMsg) {

        // This requestor is not the LLC bank generating this request,
        // but the host L1 controller to receive the data.
        // assert(machineIDToMachineType(in_msg.Requestors.singleElement()) == MachineType:L1Cache);
        assert(in_msg.Destination.isElement(machineID));

        assert(in_msg.sliceIds.isValid());

        DPRINTF(RubyStream, "Received stream indirect request [%lu, +%lu) %#x.\n", 
          in_msg.sliceIds.singleSliceId().getStartIdx(),
          in_msg.sliceIds.singleSliceId().getNumElements(),
          in_msg.addr);
        // No matter the cache line status, 
        // simply enqueue the request to L1Request message buffer.

        // Can we do this?
        se.receiveStreamIndirectRequest(in_msg);

        // Dequeue from the indirect message buffer.
        incrementLLCIndReqQueueStats();
        Tick delay := streamIndirectToL2Cache_in.dequeue(clockEdge());
        profileMsgDelay(3, ticksToCycles(delay));
      }
    }
  }

  // ! Sean: StreamAwareCache
  // Stream migrate request.
  in_port(streamMigrateToL2Cache_in, StreamMigrateRequestMsg, streamMigrateToL2Cache, rank = 0) {
    if(streamMigrateToL2Cache_in.isReady(clockEdge())) {
      peek(streamMigrateToL2Cache_in, StreamMigrateRequestMsg) {
        se.receiveStreamMigrate(in_msg.Stream, in_msg.IsCommit);
        Tick delay := streamMigrateToL2Cache_in.dequeue(clockEdge());
        profileMsgDelay(3, ticksToCycles(delay));
      }
    }
  }


  // ACTIONS

  action(a_issueFetchToMemory, "a", desc="fetch data from memory") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(DirRequestL2Network_out, RequestMsg, l2_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestors.add(machineID);
        out_msg.Destination.add(mapAddressToMachine(address, MachineType:Directory));
        out_msg.MessageSize := MessageSizeType:Control;
      }
    }
  }

  action(b_forwardRequestToExclusive, "b", desc="Forward request to the exclusive L1") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(L1RequestL2Network_out, RequestMsg, to_l1_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := in_msg.Type;
        out_msg.Requestors.addNetDest(in_msg.Requestors);
        out_msg.Destination.add(cache_entry.Exclusive);
        out_msg.MessageSize := MessageSizeType:Request_Control;
        // Don't forget to copy the slice id.
        out_msg.sliceIds := in_msg.sliceIds;
      }
    }
  }

  action(c_exclusiveReplacement, "c", desc="Send data to memory") {
    enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:MEMORY_DATA;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToMachine(address, MachineType:Directory));
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(c_exclusiveCleanReplacement, "cc", desc="Send ack to memory for clean replacement") {
    enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:ACK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToMachine(address, MachineType:Directory));
      out_msg.MessageSize := MessageSizeType:Response_Control;
    }
  }

  action(ct_exclusiveReplacementFromTBE, "ct", desc="Send data to memory") {
    enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
      assert(is_valid(tbe));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:MEMORY_DATA;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToMachine(address, MachineType:Directory));
      out_msg.DataBlk := tbe.DataBlk;
      out_msg.Dirty := tbe.Dirty;
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(d_sendDataToRequestor, "d", desc="Send data from cache to reqeustor") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;

        out_msg.AckCount := 0 - cache_entry.Sharers.count();
        if (cache_entry.Sharers.isElement(in_msg.Requestors.singleElement())) {
          out_msg.AckCount := out_msg.AckCount + 1;
        }
      }
    }
  }

  action(dd_sendExclusiveDataToRequestor, "dd", desc="Send data from cache to reqeustor") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;

        // Multicast only: Send this to core 7
        if (multicast_test) {
          MachineID multicastTestDest1 := createMachineID(MachineType:L1Cache, intToID(6));
          DPRINTF(RubyMulticast, "Multicast %#x to %s.\n", address, multicastTestDest1);
          out_msg.Destination.add(multicastTestDest1);
          MachineID multicastTestDest2 := createMachineID(MachineType:L1Cache, intToID(7));
          DPRINTF(RubyMulticast, "Multicast %#x to %s.\n", address, multicastTestDest2);
          out_msg.Destination.add(multicastTestDest2);
          MachineID multicastTestDest3 := createMachineID(MachineType:L1Cache, intToID(10));
          DPRINTF(RubyMulticast, "Multicast %#x to %s.\n", address, multicastTestDest3);
          out_msg.Destination.add(multicastTestDest3);
          MachineID multicastTestDest4 := createMachineID(MachineType:L1Cache, intToID(11));
          DPRINTF(RubyMulticast, "Multicast %#x to %s.\n", address, multicastTestDest4);
          out_msg.Destination.add(multicastTestDest4);
        }
        if (in_msg.sliceIds.isValid() && in_msg.Requestors.count() > 1) {
          DPRINTF(RubyMulticast, "Multicast Line %#x State %s\n", address, cache_entry.CacheState);
        }

        out_msg.AckCount := 0 - cache_entry.Sharers.count();
        if (cache_entry.Sharers.isElement(in_msg.Requestors.singleElement())) {
          out_msg.AckCount := out_msg.AckCount + 1;
        }
        // Don't forget to copy the stream meta-data.
        out_msg.sliceIds := in_msg.sliceIds;
        if (in_msg.sliceIds.isValid()) {
          /**
           * ! Sean: StreamAwareCache.
           * Only transmit the required sub cache line.
           */
          if (isStreamSublineEnabled()) {
            out_msg.MessageSize := getMessageSizeType(in_msg.sliceIds.singleSliceId().getSize());
          }
        }
      }
    }
  }

  action(du_sendUncacheDataToRequestors, "du", desc="Send uncache data from cache to all reqeustors") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;

        if (in_msg.sliceIds.isValid() && in_msg.Requestors.count() > 1) {
          DPRINTF(RubyMulticast, "Multicast Line %#x State %s.\n", address, cache_entry.CacheState);
        }

        /**
         * Don't forget to copy the stream meta-data.
         * So far all Uncache request is generated by Stream.
         */
        assert(in_msg.sliceIds.isValid());
        out_msg.sliceIds := in_msg.sliceIds;
        /**
         * ! Sean: StreamAwareCache.
         * Only transmit the required sub cache line.
         */
        if (isStreamSublineEnabled()) {
          out_msg.MessageSize := getMessageSizeType(in_msg.sliceIds.firstSliceId().getSize());
        }
      }
    }
  }

  action(dut_sendUncacheDataToRequestorsFromTBE, "dut", desc="Send uncache data from cache to all reqeustors from TBE") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
        assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;

        if (in_msg.sliceIds.isValid() && in_msg.Requestors.count() > 1) {
          DPRINTF(RubyMulticast, "Multicast Line %#x State %s.\n", address, tbe.TBEState);
        }

        /**
         * Don't forget to copy the stream meta-data.
         * So far all Uncache request is generated by Stream.
         */
        assert(in_msg.sliceIds.isValid());
        out_msg.sliceIds := in_msg.sliceIds;
        /**
         * ! Sean: StreamAwareCache.
         * Only transmit the required sub cache line.
         */
        if (isStreamSublineEnabled()) {
          out_msg.MessageSize := getMessageSizeType(in_msg.sliceIds.firstSliceId().getSize());
        }
      }
    }
  }


  action(ds_sendSharedDataToRequestor, "ds", desc="Send data from cache to reqeustor") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, l2_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;
        out_msg.AckCount := 0;
      }
    }
  }

  action(e_sendDataToGetSRequestors, "e", desc="Send data from cache to all GetS IDs") {
    assert(is_valid(tbe));
    assert(tbe.L1_GetS_IDs.count() > 0);
    enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.Sender := machineID;
      out_msg.Destination := tbe.L1_GetS_IDs;  // internal nodes
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(ex_sendExclusiveDataToGetSRequestors, "ex", desc="Send data from cache to all GetS IDs") {
    assert(is_valid(tbe));
    assert(tbe.L1_GetS_IDs.count() == 1);
    enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE;
      out_msg.Sender := machineID;
      out_msg.Destination := tbe.L1_GetS_IDs;  // internal nodes
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(eu_sendDataToGetURequestors, "eu", desc="Send data from cache to the GetU IDs") {
    assert(is_valid(tbe));
    if (tbe.L1_GetV_IDs.count() > 0) {
      // So far only stream can send GetV request.
      assert(tbe.sliceIds.isValid());
      enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE;
        out_msg.Sender := machineID;
        out_msg.Destination := tbe.L1_GetV_IDs;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.MessageSize := MessageSizeType:Response_Data;
        // Copy the stream meta-data.
        out_msg.sliceIds := tbe.sliceIds;
        /**
         * ! Sean: StreamAwareCache.
         * Only transmit the required sub cache line.
         */
        if (isStreamSublineEnabled()) {
          out_msg.MessageSize := getMessageSizeType(tbe.sliceIds.firstSliceId().getSize());
        }
      }
    }
  }

  action(ee_sendDataToGetXRequestor, "ee", desc="Send data from cache to GetX ID") {
    enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
      assert(is_valid(tbe));
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.Sender := machineID;
      out_msg.Destination.add(tbe.L1_GetX_ID);
      DPRINTF(RubySlicc, "%s\n", out_msg.Destination);
      out_msg.DataBlk := cache_entry.DataBlk;
      DPRINTF(RubySlicc, "Address: %#x, Destination: %s, DataBlock: %s\n",
              out_msg.addr, out_msg.Destination, out_msg.DataBlk);
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(f_sendInvToSharers, "f", desc="invalidate sharers for L2 replacement") {
    enqueue(L1RequestL2Network_out, RequestMsg, to_l1_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:INV;
      out_msg.Requestors.add(machineID);
      out_msg.Destination := cache_entry.Sharers;
      out_msg.MessageSize := MessageSizeType:Request_Control;
    }
  }

  action(fw_sendFwdInvToSharers, "fw", desc="invalidate sharers for request") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(L1RequestL2Network_out, RequestMsg, to_l1_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:INV;
        out_msg.Requestors := in_msg.Requestors;
        out_msg.Destination := cache_entry.Sharers;
        out_msg.MessageSize := MessageSizeType:Request_Control;
      }
    }
  }

  action(fwm_sendFwdInvToSharersMinusRequestor, "fwm", desc="invalidate sharers for request, requestor is sharer") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(L1RequestL2Network_out, RequestMsg, to_l1_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:INV;
        out_msg.Requestors := in_msg.Requestors;
        out_msg.Destination := cache_entry.Sharers;
        out_msg.Destination.removeNetDest(in_msg.Requestors);
        out_msg.MessageSize := MessageSizeType:Request_Control;
      }
    }
  }

  // OTHER ACTIONS
  action(i_allocateTBE, "i", desc="Allocate TBE for request") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.L1_GetS_IDs.clear();
    tbe.DataBlk := cache_entry.DataBlk;
    tbe.Dirty := cache_entry.Dirty;
    tbe.pendingAcks := cache_entry.Sharers.count();
  }

  action(css_copyStreamSliceId, "css", desc="Copy stream slice id to TBE") {
    assert(is_valid(tbe));
    peek(L1RequestL2Network_in, RequestMsg) { 
      tbe.sliceIds := in_msg.sliceIds;
    }
  }
  action(csv_copyStreamStoreValue, "csv", desc="Copy stream store value to TBE") {
    assert(is_valid(tbe));
    peek(L1RequestL2Network_in, RequestMsg) { 
      tbe.streamStoreBlk := in_msg.streamStoreBlk;
    }
  }

  action(s_deallocateTBE, "s", desc="Deallocate external TBE") {
    TBEs.deallocate(address);
    unset_tbe();
  }

  action(jj_popL1RequestQueue, "\j", desc="Pop incoming L1 request queue") {
    Tick delay := L1RequestL2Network_in.dequeue(clockEdge());
    profileMsgDelay(0, ticksToCycles(delay));
  }

  action(k_popUnblockQueue, "k", desc="Pop incoming unblock queue") {
    Tick delay := L1unblockNetwork_in.dequeue(clockEdge());
    profileMsgDelay(0, ticksToCycles(delay));
  }

  action(o_popIncomingResponseQueue, "o", desc="Pop Incoming Response queue") {
    Tick delay := responseL2Network_in.dequeue(clockEdge());
    profileMsgDelay(1, ticksToCycles(delay));
  }

  action(m_writeDataToCache, "m", desc="Write data from response queue to cache") {
    peek(responseL2Network_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.DataBlk := in_msg.DataBlk;
      if (in_msg.Dirty) {
        cache_entry.Dirty := in_msg.Dirty;
      }
    }
  }

  action(mr_writeDataToCacheFromRequest, "mr", desc="Write data from response queue to cache") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      if (in_msg.Dirty) {
        cache_entry.DataBlk := in_msg.DataBlk;
        cache_entry.Dirty := in_msg.Dirty;
      }
    }
  }

  action(q_updateAck, "q", desc="update pending ack count") {
    peek(responseL2Network_in, ResponseMsg) {
      assert(is_valid(tbe));
      tbe.pendingAcks := tbe.pendingAcks - in_msg.AckCount;
      APPEND_TRANSITION_COMMENT(in_msg.AckCount);
      APPEND_TRANSITION_COMMENT(" p: ");
      APPEND_TRANSITION_COMMENT(tbe.pendingAcks);
    }
  }

  action(qq_writeDataToTBE, "\qq", desc="Write data from response queue to TBE") {
    peek(responseL2Network_in, ResponseMsg) {
      assert(is_valid(tbe));
      tbe.DataBlk := in_msg.DataBlk;
      tbe.Dirty := in_msg.Dirty;
    }
  }

  action(ss_recordGetSL1ID, "\s", desc="Record L1 GetS for load response") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(tbe));
      tbe.L1_GetS_IDs.add(in_msg.Requestors.singleElement());
    }
  }

  action(sv_recordGetVL1ID, "\v", desc="Record L1 GetV for load response") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(tbe));
      tbe.L1_GetV_IDs.addNetDest(in_msg.Requestors);
    }
  }

  action(xx_recordGetXL1ID, "\x", desc="Record L1 GetX for store response") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(tbe));
      tbe.L1_GetX_ID := in_msg.Requestors.singleElement();
    }
  }

  action(set_setMRU, "\set", desc="set the MRU entry") {
    L2cache.setMRU(address);
  }

  action(qq_allocateL2CacheBlock, "\q", desc="Set L2 cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L2cache.allocate(address, new Entry));
    }
  }

  action(rr_deallocateL2CacheBlock, "\r", desc="Deallocate L2 cache block.  Sets the cache to not present, allowing a replacement in parallel with a fetch.") {
    L2cache.deallocate(address);
    unset_cache_entry();
  }

  action(t_sendWBAck, "t", desc="Send writeback ACK") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:WB_ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(ts_sendInvAckToUpgrader, "ts", desc="Send ACK to upgrader") {
    peek(L1RequestL2Network_in, RequestMsg) {
      enqueue(responseL2Network_out, ResponseMsg, to_l1_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.addNetDest(in_msg.Requestors);
        out_msg.MessageSize := MessageSizeType:Response_Control;
        // upgrader doesn't get ack from itself, hence the + 1
        out_msg.AckCount := 0 - cache_entry.Sharers.count() + 1;
      }
    }
  }

  action(uu_profileMiss, "\um", desc="Profile the demand miss") {
    ++L2cache.demand_misses;
    if (is_valid(tbe)) {
      if (tbe.sliceIds.isValid()) {
        se.notifyStreamRequestMiss(tbe.sliceIds);
      }
    }
  }

  action(uu_profileHit, "\uh", desc="Profile the demand hit") {
      ++L2cache.demand_hits;
  }

  action(ur_profileReq, "\ur", desc="Profile the demand request") {
    peek(L1RequestL2Network_in, RequestMsg) { 
      CoherenceRequestType type := in_msg.Type;
      bool isLoad := (type == CoherenceRequestType:GETS ||
                      type == CoherenceRequestType:GETU);
      recordLLCReqQueueStats(in_msg.requestStatistic, in_msg.sliceIds, isLoad);
    }
  }

  action(nn_addSharer, "\n", desc="Add L1 sharer to list") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      addSharer(address, in_msg.Requestors.singleElement(), cache_entry);
      APPEND_TRANSITION_COMMENT( cache_entry.Sharers );
    }
  }

  action(nnu_addSharerFromUnblock, "\nu", desc="Add L1 sharer to list") {
    peek(L1unblockNetwork_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      addSharer(address, in_msg.Sender, cache_entry);
    }
  }

  action(ns_recordMTGetVInfoFromRequest, "\ns", desc="Record required information for MT->L1_GETV") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      assert(!cache_entry.sliceIds.isValid());
      assert(in_msg.sliceIds.isValid());
      DPRINTF(LLCRubyStreamBase, "%s: Add to LLC cache entry.\n", in_msg.sliceIds);
      cache_entry.sliceIds := in_msg.sliceIds;
      cache_entry.pendingUnblocks := in_msg.Requestors.count();
    }
  }

  action(qu_updateUnblockInCacheEntry, "qu", desc="update pending unblock count in cache entry") {
    peek(L1unblockNetwork_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.pendingUnblocks := cache_entry.pendingUnblocks - 1;
    }
  }

  action(kk_removeRequestSharer, "\k", desc="Remove L1 Request sharer from list") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      cache_entry.Sharers.removeNetDest(in_msg.Requestors);
    }
  }

  action(ll_clearSharers, "\l", desc="Remove all L1 sharers from list") {
    assert(is_valid(cache_entry));
    cache_entry.Sharers.clear();
  }

  action(mm_markExclusive, "\m", desc="set the exclusive owner") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      cache_entry.Sharers.clear();
      cache_entry.Exclusive := in_msg.Requestors.singleElement();
      addSharer(address, in_msg.Requestors.singleElement(), cache_entry);
    }
  }

  action(mmu_markExclusiveFromUnblock, "\mu", desc="set the exclusive owner") {
    peek(L1unblockNetwork_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.Sharers.clear();
      cache_entry.Exclusive := in_msg.Sender;
      addSharer(address, in_msg.Sender, cache_entry);
    }
  }

  action(zz_stallAndWaitL1RequestQueue, "zz", desc="recycle L1 request queue") {
    stall_and_wait(L1RequestL2Network_in, address);
  }

  action(zn_recycleResponseNetwork, "zn", desc="recycle memory request") {
    responseL2Network_in.recycle(clockEdge(), cyclesToTicks(recycle_latency));
  }

  action(kd_wakeUpDependents, "kd", desc="wake-up dependents") {
    wakeUpBuffers(address);
  }

  /**
   * ! Sean: StreamAwareCache
   */

  action(nec_notifyStreamEngineFromCacheEntry, "nec", desc="notify the stream engine from cache entry") {
    assert(is_valid(cache_entry));
    if (cache_entry.sliceIds.isValid()) {
      // This should never be used for StreamStore.
      se.receiveStreamDataVec(l2_response_latency, address, cache_entry.sliceIds, cache_entry.DataBlk, cache_entry.DataBlk);
      // Clear the sliceId.
      cache_entry.sliceIds.clear();
    }
  }
  action(net_notifyStreamEngineFromTBE, "net", desc="notify the stream engine from TBE") {
    assert(is_valid(tbe));
    if (tbe.sliceIds.isValid()) {
      se.receiveStreamDataVec(l2_response_latency, address, tbe.sliceIds, tbe.DataBlk, tbe.streamStoreBlk);
    }
  }
  action(ner_notifyStreamEngineFromL1Req, "ner", desc="notify the stream engine from L1 request") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(cache_entry));
      if (in_msg.sliceIds.isValid()) {
        se.receiveStreamDataVec(l2_response_latency, address, in_msg.sliceIds, cache_entry.DataBlk, in_msg.streamStoreBlk);
      }
    }
  }
  action(nert_notifyStreamEngineFromL1ReqFromTBE, "nert", desc="notify the stream engine from L1 request and TBE") {
    peek(L1RequestL2Network_in, RequestMsg) {
      assert(is_valid(tbe));
      if (in_msg.sliceIds.isValid()) {
        se.receiveStreamDataVec(l2_response_latency, address, in_msg.sliceIds, tbe.DataBlk, in_msg.streamStoreBlk);
      }
    }
  }

  action(rsc_receiveStreamConfig, "rsc", desc="Receive the StreamConfig") {
    peek(L1RequestL2Network_in, RequestMsg) {
      DPRINTF(RubyStream, "Receive StreamConfig: %#x\n", in_msg.pkt);
      se.receiveStreamConfigure(in_msg.pkt);
    }
  }
  action(rsf_receiveStreamFlow, "rsf", desc="Receive the stream flow message") {
    peek(L1RequestL2Network_in, RequestMsg) {
      se.receiveStreamFlow(in_msg.sliceIds.singleSliceId());
    }
  }
  action(rscmt_receiveStreamCommit, "rscmt", desc="Receive the stream commit message") {
    peek(L1RequestL2Network_in, RequestMsg) {
      se.receiveStreamCommit(in_msg.sliceIds.singleSliceId());
    }
  }
  action(rse_receiveStreamEnd, "rse", desc="Receive the StreamEnd") {
    peek(L1RequestL2Network_in, RequestMsg) {
      se.receiveStreamEnd(in_msg.pkt);
    }
  }
  action(rsfwd_receiveStreamForward, "rsfwd", desc="Receive the StreamForward") {
    peek(L1RequestL2Network_in, RequestMsg) {
      se.receiveStreamForwardRequest(in_msg);
    }
  }
  action(rsn_receiveStreamNDC, "rsn", desc="Receive the StreamNDC") {
    peek(L1RequestL2Network_in, RequestMsg) {
      se.receiveStreamNDCRequest(in_msg.pkt);
    }
  }

  //*****************************************************
  // TRANSITIONS
  //*****************************************************


  //===============================================
  // BASE STATE - I

  // Transitions from I (Idle)
  transition({NP, IS, ISS, IM, SS, M, M_I, I_I, S_I, MT_IB, MT_SB, MT_VB}, L1_PUTX) {
    t_sendWBAck;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, I_I, S_I, IS, ISS, IM, MT_IB, MT_SB, MT_VB}, L1_PUTX_old) {
    t_sendWBAck;
    jj_popL1RequestQueue;
  }

  transition({IM, IS, ISS, IVV, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB, NP_M}, {L2_Replacement, L2_Replacement_clean}) {
    zz_stallAndWaitL1RequestQueue;
  }

  transition({IM, IS, ISS, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, MEM_Inv) {
    zn_recycleResponseNetwork;
  }

  transition({I_I, S_I, M_I, MT_I, MCT_I, NP}, MEM_Inv) {
    o_popIncomingResponseQueue;
  }
  transition({I_I, S_I, M_I, MT_I, MCT_I, NP}, MEM_InvR) {
    jj_popL1RequestQueue;
  }


  transition({SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, {L1_GETS, L1_GETV, L1_GETH, STREAM_STORE, L1_GET_INSTR, L1_GETX, L1_UPGRADE}) {
    zz_stallAndWaitL1RequestQueue;
  }

  transition({MCT_I, M_I, MT_I}, {L1_GETV, L1_GETH, STREAM_STORE}) {
    // Should only happen when the LLC stream engine request the data unknown that this line is being evicted.
    zz_stallAndWaitL1RequestQueue;
  }

  transition(NP, L1_GETS, ISS) {
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    nn_addSharer;
    i_allocateTBE;
    ss_recordGetSL1ID;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(NP, L1_GETV, IVV) {
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    i_allocateTBE;
    css_copyStreamSliceId;
    sv_recordGetVL1ID;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(NP, L1_GETH, IVV) {
    // The only difference is do not record requestor id.
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    i_allocateTBE;
    css_copyStreamSliceId;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(NP, STREAM_STORE, NP_M) {
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    i_allocateTBE;
    css_copyStreamSliceId;
    csv_copyStreamStoreValue;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(NP, L1_GET_INSTR, IS) {
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    nn_addSharer;
    i_allocateTBE;
    ss_recordGetSL1ID;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(NP, L1_GETX, IM) {
    qq_allocateL2CacheBlock;
    ll_clearSharers;
    // nn_addSharer;
    i_allocateTBE;
    xx_recordGetXL1ID;
    a_issueFetchToMemory;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  /**
   * Race condition when the LLC SE generates GETU request while the core generates GETS address.
   */
  transition(IVV, L1_GETS, ISS) {
    nn_addSharer;
    ss_recordGetSL1ID;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  // transitions from IS/IM

  transition(ISS, Mem_Data, MT_MB) {
    m_writeDataToCache;
    ex_sendExclusiveDataToGetSRequestors;
    // Also sent data to possible GETU requestor.
    net_notifyStreamEngineFromTBE;
    eu_sendDataToGetURequestors;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
  }
  
  // The data is not cached by upper requestor.
  transition(IVV, Mem_Data, M) {
    m_writeDataToCache;
    net_notifyStreamEngineFromTBE;
    eu_sendDataToGetURequestors;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS, Mem_Data, SS) {
    m_writeDataToCache;
    e_sendDataToGetSRequestors;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IM, Mem_Data, MT_MB) {
    m_writeDataToCache;
    ee_sendDataToGetXRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
  }
  transition(NP_M, Mem_Data, M) {
    qq_writeDataToTBE;
    net_notifyStreamEngineFromTBE;
    m_writeDataToCache;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition({IS, ISS}, {L1_GETS, L1_GET_INSTR}, IS) {
    nn_addSharer;
    ss_recordGetSL1ID;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition({IS, ISS}, L1_GETX) {
    zz_stallAndWaitL1RequestQueue;
  }

  transition({IVV, ISS, IS}, {L1_GETV, L1_GETH, STREAM_STORE} ) {
    // Stall the uncache request when there is a infly request to that line.
    zz_stallAndWaitL1RequestQueue;
  }

  transition({IM, NP_M}, {L1_GETV, L1_GETX, STREAM_STORE, L1_GETS, L1_GET_INSTR}) {
    zz_stallAndWaitL1RequestQueue;
  }

  // transitions from SS
  transition(SS, {L1_GETS, L1_GET_INSTR}) {
    ds_sendSharedDataToRequestor;
    nn_addSharer;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }


  transition(SS, L1_GETX, SS_MB) {
    d_sendDataToRequestor;
    // fw_sendFwdInvToSharers;
    fwm_sendFwdInvToSharersMinusRequestor;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition(SS, L1_UPGRADE, SS_MB) {
    fwm_sendFwdInvToSharersMinusRequestor;
    ts_sendInvAckToUpgrader;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition(SS, L2_Replacement_clean, I_I) {
    i_allocateTBE;
    f_sendInvToSharers;
    rr_deallocateL2CacheBlock;
  }

  transition(SS, {L2_Replacement, MEM_Inv, MEM_InvR}, S_I) {
    i_allocateTBE;
    f_sendInvToSharers;
    rr_deallocateL2CacheBlock;
  }
  // The data may be cached somewhere above, but we have the correct copy. 
  transition(SS, L1_GETV, SS) {
    ner_notifyStreamEngineFromL1Req;
    du_sendUncacheDataToRequestors;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  // The data is in TBE now.
  transition({S_I, I_I}, L1_GETV) {
    nert_notifyStreamEngineFromL1ReqFromTBE;
    dut_sendUncacheDataToRequestorsFromTBE;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(SS, L1_GETH, SS) {
    ner_notifyStreamEngineFromL1Req;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(SS, STREAM_STORE, SS_M) {
    i_allocateTBE; 
    css_copyStreamSliceId;
    csv_copyStreamStoreValue;
    f_sendInvToSharers;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition(S_I, Ack) {
    q_updateAck;
    o_popIncomingResponseQueue;
  }
  transition(S_I, Ack_all, M_I) {
    ct_exclusiveReplacementFromTBE;
    o_popIncomingResponseQueue;
  }
  transition(SS_M, Ack) {
    q_updateAck;
    o_popIncomingResponseQueue;
  }
  transition(SS_M, Ack_all, M) {
    ll_clearSharers;
    net_notifyStreamEngineFromTBE;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(M, L1_GETX, MT_MB) {
    d_sendDataToRequestor;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition(M, L1_GET_INSTR, SS) {
    d_sendDataToRequestor;
    nn_addSharer;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  transition(M, L1_GETS, MT_MB) {
    dd_sendExclusiveDataToRequestor;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }

  // The data is not cached above.
  transition(M, L1_GETV, M) {
    ner_notifyStreamEngineFromL1Req;
    du_sendUncacheDataToRequestors;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(M, L1_GETH, M) {
    ner_notifyStreamEngineFromL1Req;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(M, STREAM_STORE, M) {
    ner_notifyStreamEngineFromL1Req;
    set_setMRU;
    uu_profileHit;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(M, {L2_Replacement, MEM_Inv, MEM_InvR}, M_I) {
    i_allocateTBE;
    c_exclusiveReplacement;
    rr_deallocateL2CacheBlock;
  }

  transition(M, L2_Replacement_clean, M_I) {
    i_allocateTBE;
    c_exclusiveCleanReplacement;
    rr_deallocateL2CacheBlock;
  }


  // transitions from MT

  transition(MT, L1_GETX, MT_MB) {
    b_forwardRequestToExclusive;
    uu_profileMiss;
    ur_profileReq;
    set_setMRU;
    jj_popL1RequestQueue;
  }
  transition(MT, {L1_GETS, L1_GET_INSTR}, MT_IIB) {
    b_forwardRequestToExclusive;
    uu_profileMiss;
    ur_profileReq;
    set_setMRU;
    jj_popL1RequestQueue;
  }
  transition(MT, L1_GETV, MT_VVB) {
    /**
     * For uncached request, we transit to MT_VVB.
     * The only difference from MT_IIB is that we do not add sharer from Unblock.
     */
    b_forwardRequestToExclusive;
    ns_recordMTGetVInfoFromRequest;
    uu_profileMiss;
    ur_profileReq;
    set_setMRU;
    jj_popL1RequestQueue;
  }
  transition(MT, L1_GETH, MT_M) {
    // For L1_GETH at MT state, we treate it the same as STREAM_STORE.
    i_allocateTBE;
    css_copyStreamSliceId;
    f_sendInvToSharers;
    set_setMRU;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  /**
   * This means LLC's data is stale. We actually need to invalidate other's
   * copy and then update the data.
   * MT -> MT_M -> M
   */
  transition(MT, STREAM_STORE, MT_M) {
    i_allocateTBE;
    css_copyStreamSliceId;
    csv_copyStreamStoreValue;
    f_sendInvToSharers;
    set_setMRU;
    uu_profileMiss;
    ur_profileReq;
    jj_popL1RequestQueue;
  }
  transition(MT, {L2_Replacement, MEM_Inv, MEM_InvR}, MT_I) {
    i_allocateTBE;
    f_sendInvToSharers;
    rr_deallocateL2CacheBlock;
  }
  transition(MT, L2_Replacement_clean, MCT_I) {
    i_allocateTBE;
    f_sendInvToSharers;
    rr_deallocateL2CacheBlock;
  }
  transition(MT, L1_PUTX, M) {
    ll_clearSharers;
    mr_writeDataToCacheFromRequest;
    t_sendWBAck;
    jj_popL1RequestQueue;
  }

  transition({SS_MB, MT_MB}, Exclusive_Unblock, MT) {
    // update actual directory
    mmu_markExclusiveFromUnblock;
    k_popUnblockQueue;
    kd_wakeUpDependents;
  }

  transition({MT_IIB, MT_VVB}, {L1_PUTX, L1_PUTX_old}){
    zz_stallAndWaitL1RequestQueue;
  }

  transition(MT_IIB, Unblock, MT_IB) {
    nnu_addSharerFromUnblock;
    k_popUnblockQueue;
  }
  transition(MT_VVB, Pre_Unblock, MT_VVB) {
    qu_updateUnblockInCacheEntry;
    k_popUnblockQueue;
  }
  transition(MT_VVB, Unblock, MT_IB) {
    qu_updateUnblockInCacheEntry;
    k_popUnblockQueue;
  }

  transition(MT_IIB, {WB_Data, WB_Data_clean}, MT_SB) {
    m_writeDataToCache;
    o_popIncomingResponseQueue;
  }
  transition(MT_VVB, {WB_Data, WB_Data_clean}, MT_VB) {
    m_writeDataToCache;
    o_popIncomingResponseQueue;
  }

  transition(MT_IB, {WB_Data, WB_Data_clean}, SS) {
    m_writeDataToCache;
    nec_notifyStreamEngineFromCacheEntry;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(MT_SB, Unblock, SS) {
    nnu_addSharerFromUnblock;
    nec_notifyStreamEngineFromCacheEntry;
    k_popUnblockQueue;
    kd_wakeUpDependents;
  }
  transition(MT_VB, Pre_Unblock, MT_VB) {
    qu_updateUnblockInCacheEntry;
    k_popUnblockQueue;
  }
  transition(MT_VB, Unblock, SS) {
    qu_updateUnblockInCacheEntry;
    nec_notifyStreamEngineFromCacheEntry;
    k_popUnblockQueue;
    kd_wakeUpDependents;
  }

  transition(MT_M, WB_Data, M) {
    qq_writeDataToTBE;
    net_notifyStreamEngineFromTBE;
    ll_clearSharers;
    m_writeDataToCache;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }
  transition(MT_M, {WB_Data_clean, Ack_all}, M) {
    net_notifyStreamEngineFromTBE;
    ll_clearSharers;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // writeback states
  transition({I_I, S_I, MT_I, MCT_I, M_I}, {L1_GETX, L1_UPGRADE, L1_GETS, L1_GET_INSTR}) {
    zz_stallAndWaitL1RequestQueue;
  }

  transition(I_I, Ack) {
    q_updateAck;
    o_popIncomingResponseQueue;
  }

  transition(I_I, Ack_all, M_I) {
    c_exclusiveCleanReplacement;
    o_popIncomingResponseQueue;
  }

  transition({MT_I, MCT_I}, WB_Data, M_I) {
    qq_writeDataToTBE;
    ct_exclusiveReplacementFromTBE;
    o_popIncomingResponseQueue;
  }

  transition(MCT_I, {WB_Data_clean, Ack_all}, M_I) {
    c_exclusiveCleanReplacement;
    o_popIncomingResponseQueue;
  }

  transition(MCT_I,  {L1_PUTX, L1_PUTX_old}){
    zz_stallAndWaitL1RequestQueue;
  }

  // L1 never changed Dirty data
  transition(MT_I, {WB_Data_clean, Ack_all}, M_I) {
    ct_exclusiveReplacementFromTBE;
    o_popIncomingResponseQueue;
  }

  transition(MT_I, {L1_PUTX, L1_PUTX_old}){
    zz_stallAndWaitL1RequestQueue;
  }

  // possible race between unblock and immediate replacement
  transition({MT_MB, MT_M, SS_MB, SS_M}, {L1_PUTX, L1_PUTX_old}) {
    zz_stallAndWaitL1RequestQueue;
  }

  transition(M_I, Mem_Ack, NP) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  /**
   * Sean: StreamAwareCache.
   */
  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_CONFIG) {
    rsc_receiveStreamConfig;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_FLOW) {
    rsf_receiveStreamFlow;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_COMMIT) {
    rscmt_receiveStreamCommit;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_END) {
    rse_receiveStreamEnd;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_FORWARD) {
    rsfwd_receiveStreamForward;
    jj_popL1RequestQueue;
  }

  transition({NP, SS, M, MT, M_I, MT_I, MCT_I, I_I, S_I, IVV, ISS, IS, IM, NP_M, SS_MB, SS_M, MT_MB, MT_M, MT_IIB, MT_VVB, MT_IB, MT_SB, MT_VB}, STREAM_NDC) {
    rsn_receiveStreamNDC;
    jj_popL1RequestQueue;
  }
}
